import numpy as np
from collections import OrderedDict
from abc import abstractmethod
from uuid import uuid4
from six import with_metaclass
from .utils import docval, get_docval, call_docval_func, getargs, ExtenderMeta, get_data_shape
from .data_utils import DataIO
from warnings import warn
import xarray as xr
import h5py


class AbstractContainer(with_metaclass(ExtenderMeta, object)):

    # The name of the class attribute that subclasses use to autogenerate properties
    # This parameterization is supplied in case users would like to configure
    # the class attribute name to something domain-specific
    _fieldsname = '__fields__'

    _data_type_attr = 'data_type'

    # Subclasses use this class attribute to add properties to autogenerate
    # Autogenerated properties will store values in self.__field_values
    __fields__ = tuple()

    _pconf_allowed_keys = {'name', 'doc', 'settable'}

    # Override the _setter factor function, so directives that apply to
    # Container do not get used on Data
    @classmethod
    def _setter(cls, field):
        """
        Make a setter function for creating a :py:func:`property`
        """
        name = field['name']

        if not field.get('settable', True):
            return None

        def setter(self, val):
            if val is None:
                return
            if name in self.fields:
                msg = "can't set attribute '%s' -- already set" % name
                raise AttributeError(msg)
            self.fields[name] = val

        return setter

    @classmethod
    def _getter(cls, field):
        """
        Make a getter function for creating a :py:func:`property`
        """
        doc = field.get('doc')
        name = field['name']

        def getter(self):
            return self.fields.get(name)

        setattr(getter, '__doc__', doc)
        return getter

    @staticmethod
    def _check_field_spec(field):
        """
        A helper function for __gather_fields to make sure we are always working
        with a dict specification and that the specification contains the correct keys
        """
        tmp = field
        if isinstance(tmp, dict):
            if 'name' not in tmp:
                raise ValueError("must specify 'name' if using dict in __fields__")
        else:
            tmp = {'name': tmp}
        return tmp

    @ExtenderMeta.pre_init
    def __gather_fields(cls, name, bases, classdict):
        '''
        This classmethod will be called during class declaration in the metaclass to automatically
        create setters and getters for fields that need to be exported
        '''
        fields = getattr(cls, cls._fieldsname)
        if not isinstance(fields, tuple):
            msg = "'%s' must be of type tuple" % cls._fieldsname
            raise TypeError(msg)

        if len(bases) and 'Container' in globals() and issubclass(bases[-1], Container) \
                and getattr(bases[-1], bases[-1]._fieldsname) is not fields:
            new_fields = list(fields)
            new_fields[0:0] = getattr(bases[-1], bases[-1]._fieldsname)
            setattr(cls, cls._fieldsname, tuple(new_fields))
        new_fields = list()
        docs = {dv['name']: dv['doc'] for dv in get_docval(cls.__init__)}
        for f in getattr(cls, cls._fieldsname):
            pconf = cls._check_field_spec(f)
            pname = pconf['name']
            pconf.setdefault('doc', docs.get(pname))
            if not hasattr(cls, pname):
                setattr(cls, pname, property(cls._getter(pconf), cls._setter(pconf)))
            new_fields.append(pname)
        setattr(cls, cls._fieldsname, tuple(new_fields))

    def __new__(cls, *args, **kwargs):
        inst = super().__new__(cls)
        inst.__container_source = kwargs.pop('container_source', None)
        inst.__parent = None
        inst.__children = list()
        inst.__modified = True
        inst.__object_id = kwargs.pop('object_id', str(uuid4()))
        inst.parent = kwargs.pop('parent', None)
        return inst

    @docval({'name': 'name', 'type': str, 'doc': 'the name of this container'})
    def __init__(self, **kwargs):
        name = getargs('name', kwargs)
        if '/' in name:
            raise ValueError("name '" + name + "' cannot contain '/'")
        self.__name = name
        self.__field_values = dict()

    @property
    def name(self):
        '''
        The name of this Container
        '''
        return self.__name

    @docval({'name': 'data_type', 'type': str, 'doc': 'the data_type to search for', 'default': None})
    def get_ancestor(self, **kwargs):
        """
        Traverse parent hierarchy and return first instance of the specified data_type
        """
        data_type = getargs('data_type', kwargs)
        if data_type is None:
            return self.parent
        p = self.parent
        while p is not None:
            if getattr(p, p._data_type_attr) == data_type:
                return p
            p = p.parent
        return None

    @property
    def fields(self):
        return self.__field_values

    @property
    def object_id(self):
        if self.__object_id is None:
            self.__object_id = str(uuid4())
        return self.__object_id

    @property
    def modified(self):
        return self.__modified

    @docval({'name': 'modified', 'type': bool,
             'doc': 'whether or not this AbstractContainer has been modified', 'default': True})
    def set_modified(self, **kwargs):
        modified = getargs('modified', kwargs)
        self.__modified = modified
        if modified and isinstance(self.parent, AbstractContainer):
            self.parent.set_modified()

    @property
    def children(self):
        return tuple(self.__children)

    @docval({'name': 'child', 'type': 'AbstractContainer',
             'doc': 'the child AbstractContainer for this AbstractContainer', 'default': None})
    def add_child(self, **kwargs):
        warn(DeprecationWarning('add_child is deprecated. Set the parent attribute instead.'))
        child = getargs('child', kwargs)
        if child is not None:
            # if child.parent is a Container, then the mismatch between child.parent and parent
            # is used to make a soft/external link from the parent to a child elsewhere
            # if child.parent is not a Container, it is either None or a Proxy and should be set to self
            if not isinstance(child.parent, AbstractContainer):
                # actually add the child to the parent in parent setter
                child.parent = self
        else:
            warn('Cannot add None as child to a container %s' % self.name)

    @classmethod
    def type_hierarchy(cls):
        return cls.__mro__

    @property
    def container_source(self):
        '''
        The source of this Container
        '''
        return self.__container_source

    @container_source.setter
    def container_source(self, source):
        if self.__container_source is not None:
            raise Exception('cannot reassign container_source')
        self.__container_source = source

    @property
    def parent(self):
        '''
        The parent Container of this Container
        '''
        # do it this way because __parent may not exist yet (not set in constructor)
        return getattr(self, '_AbstractContainer__parent', None)

    @parent.setter
    def parent(self, parent_container):
        if self.parent is parent_container:
            return

        if self.parent is not None:
            if isinstance(self.parent, AbstractContainer):
                raise ValueError(('Cannot reassign parent to: %s. Parent is already: %s.'
                                  % (repr(self), repr(self.parent))))
            else:
                if parent_container is None:
                    raise ValueError("Got None for parent of '%s' - cannot overwrite Proxy with NoneType" % repr(self))
                # TODO this assumes isinstance(parent_container, Proxy) but
                # circular import if we try to do that. Proxy would need to move
                # or Container extended with this functionality in build/map.py
                if self.parent.matches(parent_container):
                    self.__parent = parent_container
                    parent_container.__children.append(self)
                    parent_container.set_modified()
                else:
                    self.__parent.add_candidate(parent_container)
        else:
            self.__parent = parent_container
            if isinstance(parent_container, AbstractContainer):
                parent_container.__children.append(self)
                parent_container.set_modified()


class Container(AbstractContainer):

    @docval({'name': 'name', 'type': str, 'doc': 'the name of this container'})
    def __init__(self, **kwargs):
        call_docval_func(super().__init__, kwargs)
        # dict of active dimension names, where key is name of data array and value is a list of names, one per axis
        self.__dims = dict()
        # dict of dimension coordinates, where key is name of data array and value is a list of label-dataset pairs
        self.__coords = dict()

    _pconf_allowed_keys = {'name', 'child', 'required_name', 'doc', 'settable'}

    @classmethod
    def _setter(cls, field):
        super_setter = AbstractContainer._setter(field)
        ret = [super_setter]
        if isinstance(field, dict):
            for k in field.keys():
                if k not in cls._pconf_allowed_keys:
                    msg = "Unrecognized key '%s' in __field__ config '%s' on %s" % (k, field['name'], cls.__name__)
                    raise ValueError(msg)
            if field.get('required_name', None) is not None:
                name = field['required_name']
                idx1 = len(ret) - 1

                def container_setter(self, val):
                    if val is not None and val.name != name:
                        msg = "%s field on %s must be named '%s'" % (field['name'], self.__class__.__name__, name)
                        raise ValueError(msg)
                    ret[idx1](self, val)

                ret.append(container_setter)
            if field.get('child', False):
                idx2 = len(ret) - 1

                def container_setter(self, val):
                    ret[idx2](self, val)
                    if val is not None:
                        if isinstance(val, (tuple, list)):
                            pass
                        elif isinstance(val, dict):
                            val = val.values()
                        else:
                            val = [val]
                        for v in val:
                            if not isinstance(v.parent, Container):
                                v.parent = self
                            # else, the ObjectMapper will create a link from self (parent) to v (child with existing
                            # parent)

                ret.append(container_setter)
        return ret[-1]

    def __repr__(self):
        cls = self.__class__
        template = "%s %s.%s at 0x%d" % (self.name, cls.__module__, cls.__name__, id(self))
        if len(self.fields):
            template += "\nFields:\n"
        for k in sorted(self.fields):  # sorted to enable tests
            v = self.fields[k]
            # if isinstance(v, DataIO) or not hasattr(v, '__len__') or len(v) > 0:
            if hasattr(v, '__len__'):
                if isinstance(v, (np.ndarray, list, tuple)):
                    if len(v) > 0:
                        template += "  {}: {}\n".format(k, self.__smart_str(v, 1))
                elif v:
                    template += "  {}: {}\n".format(k, self.__smart_str(v, 1))
            else:
                template += "  {}: {}\n".format(k, v)
        return template

    @staticmethod
    def __smart_str(v, num_indent):
        """
        Print compact string representation of data.

        If v is a list, try to print it using numpy. This will condense the string
        representation of datasets with many elements. If that doesn't work, just print the list.

        If v is a dictionary, print the name and type of each element

        If v is a set, print it sorted

        If v is a neurodata_type, print the name of type

        Otherwise, use the built-in str()
        Parameters
        ----------
        v

        Returns
        -------
        str

        """

        if isinstance(v, list) or isinstance(v, tuple):
            if len(v) and isinstance(v[0], AbstractContainer):
                return Container.__smart_str_list(v, num_indent, '(')
            try:
                return str(np.asarray(v))
            except ValueError:
                return Container.__smart_str_list(v, num_indent, '(')
        elif isinstance(v, dict):
            return Container.__smart_str_dict(v, num_indent)
        elif isinstance(v, set):
            return Container.__smart_str_list(sorted(list(v)), num_indent, '{')
        elif isinstance(v, AbstractContainer):
            return "{} {}".format(getattr(v, 'name'), type(v))
        else:
            return str(v)

    @staticmethod
    def __smart_str_list(l, num_indent, left_br):
        if left_br == '(':
            right_br = ')'
        if left_br == '{':
            right_br = '}'
        if len(l) == 0:
            return left_br + ' ' + right_br
        indent = num_indent * 2 * ' '
        indent_in = (num_indent + 1) * 2 * ' '
        out = left_br
        for v in l[:-1]:
            out += '\n' + indent_in + Container.__smart_str(v, num_indent + 1) + ','
        if l:
            out += '\n' + indent_in + Container.__smart_str(l[-1], num_indent + 1)
        out += '\n' + indent + right_br
        return out

    @staticmethod
    def __smart_str_dict(d, num_indent):
        left_br = '{'
        right_br = '}'
        if len(d) == 0:
            return left_br + ' ' + right_br
        indent = num_indent * 2 * ' '
        indent_in = (num_indent + 1) * 2 * ' '
        out = left_br
        keys = sorted(list(d.keys()))
        for k in keys[:-1]:
            out += '\n' + indent_in + Container.__smart_str(k, num_indent + 1) + ' ' + str(type(d[k])) + ','
        if keys:
            out += '\n' + indent_in + Container.__smart_str(keys[-1], num_indent + 1) + ' ' + str(type(d[keys[-1]]))
        out += '\n' + indent + right_br
        return out

    @property
    def dims(self):
        '''
        Return a dict of dimension names, indexed by data array name, for this Container. Each value is a list of
        names, one for each dimension of the array.
        '''
        # TODO: decide whether to return only active dims
        return self.__dims

    @docval({'name': 'data_name', 'type': str, 'doc': ''},
            {'name': 'dim', 'type': str, 'doc': ''})
    def _get_dim_axis(self, **kwargs):
        '''
        Returns the axis corresponding to the given dimension of the given array.
        '''
        data_name, dim = getargs('data_name', 'dim', kwargs)
        if data_name not in self.fields:
            raise ValueError("No field named '%s' in %s." % (data_name, self.__class__.__name__))
        if data_name not in self.dims:
            return None  # TODO should this return None or raise an error?
        try:
            axis = self.dims[data_name].index(dim)
        except ValueError:
            raise ValueError("Dim name '%s' not found for field '%s' of %s."
                             % (dim, data_name, self.__class__.__name__))
        return axis

    @docval({'name': 'data_name', 'type': str, 'doc': ''},
            {'name': 'dims', 'type': tuple, 'doc': ''})
    def set_dims(self, **kwargs):
        data_name, dims = getargs('data_name', 'dims', kwargs)
        if data_name not in self.fields:
            raise ValueError("No field named '%s' in %s." % (data_name, self.__class__.__name__))
        if data_name in self.dims:
            raise ValueError("Cannot reset dims for field %s in %s. Dims are already %s."
                             % (data_name, self.__class__.__name__, self.dims[data_name]))
        if not Container.__all_unique(dims):
            raise ValueError("Cannot set dims for field %s in %s. Dims must be unique."
                             % (data_name, self.__class__.__name__))
        self.dims[data_name] = dims

    @staticmethod
    def __all_unique(x):
        seen = set()
        return not any(i in seen or seen.add(i) for i in x)

    @docval({'name': 'data_name', 'type': str, 'doc': ''},
            {'name': 'axis', 'type': int, 'doc': ''},
            {'name': 'dim', 'type': str, 'doc': ''})
    def set_dim(self, **kwargs):
        # TODO dims should really not be mutable after first setting it. BUT what happens if data changes?
        data_name, axis, dim = getargs('data_name', 'axis', 'dim', kwargs)
        if data_name not in self.fields:
            raise ValueError("No field named '%s' in %s." % (data_name, self.__class__.__name__))
        if data_name in self.dims and self.dims[data_name][axis] is not None:
            raise ValueError("Cannot reset dims for axis %d of field %s in %s. Dim is already %s."
                             % (axis, data_name, self.__class__.__name__, self.dims[data_name][axis]))
        data = getattr(self, data_name)
        data_shape = get_data_shape(data)
        if data_shape is None:
            raise ValueError("Cannot determine shape of field '%s' in %s." % (data_name, self.__class__.__name__))
        num_data_dims = len(data_shape)
        if axis < 0 or axis >= num_data_dims:
            raise ValueError("Axis %d does not exist for field '%s' in %s."
                             % (axis, data_name, self.__class__.__name__))
        if data_name not in self.dims:
            self.dims[data_name] = [None] * num_data_dims
            for di in range(num_data_dims):
                self.dims[data_name][di] = 'dim_%d' % di  # default initialization for other fields
        if dim in self.dims[data_name] and self.dims[data_name].index(dim) != axis:
            raise ValueError("Cannot set dim '%s' for axis %d of field %s in %s. Dim '%s' is already used for axis %d."
                             % (dim, axis, data_name, self.__class__.__name__, dim, self.dims[data_name].index(dim)))
        self.dims[data_name][axis] = dim

    @property
    def coords(self):
        '''
        Return a dictionary of coordinates, indexed by array name, for this Container. Each value is a dictionary of
        coordinates, indexed by label, where the value is a tuple: (tuple of dimension names, the coordinate array).
        '''
        return self.__coords

    @docval({'name': 'data_name', 'type': str, 'doc': ''},
            {'name': 'name', 'type': str, 'doc': ''},
            {'name': 'coord_data_name', 'type': str, 'doc': ''},
            {'name': 'axes', 'type': (str, list, tuple), 'doc': '', 'default': None})
    def set_coord(self, **kwargs):
        '''
        Sets a coordinate and coordinate label for a given data array in this Container.
        Usage examples:
        Field 'data' has dim 'time' for axis 0, 'electrodes' for axis 1.
        Field 'timestamps' has cooordinates for axis 0 of data and length equal to data.shape[0].
        set_coord(data_name='data', label='my_time', coord='timestamps', dim='time')
        will result in
        self.coords['data']['my_time'] == ('time', self.timestamps)
        Field 'data' has dim 'frame' for axis 0, 'y' for axis 1, and 'x' for axis 2.
        Field 'dorsal_ventral' has coordinate for axes 1 and 2 of data and shape equal to (data.shape[1], data.shape[2])
        set_coord(data_name='data', label='dv', coord='dorsal-ventral', dim=('y', 'x'))
        will result in
        self.coords['data']['dv'] == (('y', 'x'), self.dorsal_ventral)
        '''
        data_name, label, coord, dims = getargs('data_name', 'label', 'coord', 'dims', kwargs)
        if dims is None:  # if dim is not provided, the dimension is the same as the label
            dims = (label, )
        if data_name not in self.fields:
            raise ValueError("Field name '%s' not found in %s." % (data_name, self.__class__.__name__))
        if data_name not in self.dims:
            raise ValueError("No dimensions have been specified for '%s' in %s." % (data_name, self.__class__.__name__))
        if isinstance(dims, str):
            dims = (dims, )
        dims = tuple(dims)
        for d in dims:
            if d not in self.dims[data_name]:
                raise ValueError("Dimension '%s' not found in dimensions for field '%s' in %s."
                                 % (d, data_name, self.__class__.__name__))
        if coord not in self.fields:
            raise ValueError("Coord name '%s' not found in %s." % (coord, self.__class__.__name__))
        if data_name == coord:
            raise ValueError("Cannot set coord '%s' to itself in %s." % (coord, self.__class__.__name__))

        # TODO check that dimensions of coord are aligned with dimensions of data_name on axis
        data = getattr(self, data_name)
        data_shape = get_data_shape(data)
        coord_data = getattr(self, coord)
        coord_shape = get_data_shape(coord_data)

        for di, d in enumerate(dims):
            axis = self._get_dim_axis(data_name=data_name, dim=d)
            if data_shape[axis] != coord_shape[di]:
                raise ValueError(("Dimension '%s' of field '%s' must have the same length as axis %d of "
                                  "field '%s' in %s (%d != %d).")
                                 % (d, data_name, di, coord, self.__class__.__name__,
                                    data_shape[axis], coord_shape[di]))

        if data_name not in self.coords:
            self.coords[data_name] = dict()

        self.coords[data_name][label] = (dims, coord_data)

    @docval({'name': 'data_name', 'type': str, 'doc': ''})
    def to_xarray_dataarray(self, **kwargs):
        '''
        Returns an xarray.DataArray for the given multidimensional array in this Container, with dims and coords set.
        '''
        data_name = getargs('data_name', kwargs)
        if data_name not in self.fields:
            raise ValueError("Field name '%s' not found in %s." % (data_name, self.__class__.__name__))
        kwargs = dict()
        if data_name in self.dims:
            kwargs['dims'] = self.dims[data_name]
        if data_name in self.coords:
            kwargs['coords'] = self.coords[data_name]
        arr = xr.DataArray(getattr(self, data_name), **kwargs)
        return arr

    @docval({'name': 'data_name', 'type': str, 'doc': ''})
    def to_xarray_dataset(self, **kwargs):
        '''Returns an xarray.Dataset of all of the labeled multidimensional arrays in this Container.'''
        pass


class Data(AbstractContainer):
    """
    A class for representing dataset containers
    """

    @docval({'name': 'name', 'type': str, 'doc': 'the name of this container'},
            {'name': 'data', 'type': ('array_data', 'data'), 'doc': 'the source of the data'})
    def __init__(self, **kwargs):
        call_docval_func(super().__init__, kwargs)
        self.__data = getargs('data', kwargs)

    @property
    def data(self):
        return self.__data

    @property
    def shape(self):
        """
        Get the shape of the data represented by this container
        :return: Shape tuple
        :rtype: tuple of ints
        """
        return get_data_shape(self.__data)

    @docval({'name': 'dataio', 'type': DataIO, 'doc': 'the DataIO to apply to the data held by this Data'})
    def set_dataio(self, **kwargs):
        """
        Apply DataIO object to the data held by this Data object
        """
        dataio = getargs('dataio', kwargs)
        dataio.data = self.__data
        self.__data = dataio

    def __bool__(self):
        return len(self.data) != 0

    def __len__(self):
        return len(self.__data)

    def __getitem__(self, args):
        if isinstance(self.data, (tuple, list)) and isinstance(args, (tuple, list)):
            return [self.data[i] for i in args]
        return self.data[args]

    def append(self, arg):
        if isinstance(self.data, list):
            self.data.append(arg)
        elif isinstance(self.data, np.ndarray):
            self.__data = np.append(self.__data, [arg])
        elif isinstance(self.data, h5py.Dataset):
            shape = list(self.__data.shape)
            shape[0] += 1
            self.__data.resize(shape)
            self.__data[-1] = arg
        else:
            msg = "Data cannot append to object of type '%s'" % type(self.__data)
            raise ValueError(msg)

    def extend(self, arg):
        if isinstance(self.data, list):
            self.data.extend(arg)
        elif isinstance(self.data, np.ndarray):
            self.__data = np.append(self.__data, [arg])
        elif isinstance(self.data, h5py.Dataset):
            shape = list(self.__data.shape)
            shape[0] += len(arg)
            self.__data.resize(shape)
            self.__data[-len(arg):] = arg
        else:
            msg = "Data cannot extend object of type '%s'" % type(self.__data)
            raise ValueError(msg)


class DataRegion(Data):

    @property
    @abstractmethod
    def data(self):
        '''
        The target data that this region applies to
        '''
        pass

    @property
    @abstractmethod
    def region(self):
        '''
        The region that indexes into data e.g. slice or list of indices
        '''
        pass
